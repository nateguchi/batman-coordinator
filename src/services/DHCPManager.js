const { exec } = require('child_process');
const { promisify } = require('util');
const fs = require('fs').promises;
const path = require('path');
const logger = require('../utils/logger');

const execAsync = promisify(exec);

class DHCPManager {
    constructor() {
        this.dhcpConfigPath = '/etc/dhcp/dhcpd.conf';
        this.dhcpLeasesPath = '/var/lib/dhcp/dhcpd.leases';
        this.interface = process.env.BATMAN_INTERFACE || 'bat0';
        this.meshSubnet = process.env.MESH_SUBNET || '192.168.100.0/24';
        this.coordinatorIP = process.env.COORDINATOR_BATMAN_IP || '192.168.100.1';
        this.dhcpRange = process.env.DHCP_RANGE || '192.168.100.10 192.168.100.250';
        this.isEnabled = false;
    }

    async executeCommand(command, options = {}) {
        try {
            logger.debug(`Executing DHCP command: ${command}`);
            const { stdout, stderr } = await execAsync(command, { timeout: 30000, ...options });
            if (stderr && !options.ignoreStderr) {
                logger.warn(`DHCP command stderr: ${stderr}`);
            }
            return stdout.trim();
        } catch (error) {
            logger.error(`DHCP command failed: ${command}`, error);
            throw error;
        }
    }

    async installDHCPServer() {
        try {
            logger.info('Installing DHCP server...');
            
            // Check if already installed
            try {
                await this.executeCommand('which dhcpd');
                logger.info('DHCP server already installed');
                return;
            } catch (error) {
                // Not installed, proceed with installation
            }
            
            // Install ISC DHCP server
            await this.executeCommand('apt-get update');
            await this.executeCommand('apt-get install -y isc-dhcp-server');
            
            logger.info('DHCP server installed successfully');
            
        } catch (error) {
            logger.error('Failed to install DHCP server:', error);
            throw error;
        }
    }

    async generateDHCPConfig() {
        try {
            const [networkAddr, prefixLength] = this.meshSubnet.split('/');
            const [a, b, c, d] = networkAddr.split('.').map(Number);
            
            // Calculate network and broadcast addresses
            const hostBits = 32 - parseInt(prefixLength);
            const netmask = (0xFFFFFFFF << hostBits) >>> 0;
            const netmaskStr = [
                (netmask >>> 24) & 0xFF,
                (netmask >>> 16) & 0xFF,
                (netmask >>> 8) & 0xFF,
                netmask & 0xFF
            ].join('.');
            
            const broadcastAddr = [
                a | ((~netmask >>> 24) & 0xFF),
                b | ((~netmask >>> 16) & 0xFF),
                c | ((~netmask >>> 8) & 0xFF),
                d | (~netmask & 0xFF)
            ].join('.');

            const dhcpConfig = `# DHCP Server Configuration for Batman Mesh Network
# Generated by Batman Coordinator

# Global settings
default-lease-time 600;
max-lease-time 7200;
authoritative;
log-facility local7;

# Mesh network subnet
subnet ${networkAddr} netmask ${netmaskStr} {
    range ${this.dhcpRange};
    option routers ${this.coordinatorIP};
    option subnet-mask ${netmaskStr};
    option broadcast-address ${broadcastAddr};
    option domain-name-servers 8.8.8.8, 8.8.4.4;
    option domain-name "mesh.local";
    
    # Lease time for mesh nodes
    default-lease-time 1800;  # 30 minutes
    max-lease-time 3600;      # 1 hour
    
    # Send coordinator as gateway
    option routers ${this.coordinatorIP};
}

# Host declarations for known nodes (optional)
# Add static assignments here if needed
`;

            return dhcpConfig;
            
        } catch (error) {
            logger.error('Failed to generate DHCP config:', error);
            throw error;
        }
    }

    async writeDHCPConfig() {
        try {
            logger.info('Writing DHCP configuration...');
            
            const config = await this.generateDHCPConfig();
            
            // Backup existing config if it exists
            try {
                await fs.access(this.dhcpConfigPath);
                await this.executeCommand(`cp ${this.dhcpConfigPath} ${this.dhcpConfigPath}.backup.$(date +%s)`);
                logger.info('Backed up existing DHCP config');
            } catch (error) {
                // Config doesn't exist, that's fine
            }
            
            // Write new config
            await fs.writeFile(this.dhcpConfigPath, config);
            logger.info(`DHCP configuration written to ${this.dhcpConfigPath}`);
            
        } catch (error) {
            logger.error('Failed to write DHCP config:', error);
            throw error;
        }
    }

    async configureDHCPDefaults() {
        try {
            logger.info('Configuring DHCP server defaults...');
            
            const defaultsPath = '/etc/default/isc-dhcp-server';
            
            // Read existing defaults
            let defaultsContent = '';
            try {
                defaultsContent = await fs.readFile(defaultsPath, 'utf8');
            } catch (error) {
                // File doesn't exist, create new
            }
            
            // Update or add interface configuration
            const interfaceLine = `INTERFACESv4="${this.interface}"`;
            
            if (defaultsContent.includes('INTERFACESv4=')) {
                // Replace existing line
                defaultsContent = defaultsContent.replace(/INTERFACESv4=.*/, interfaceLine);
            } else {
                // Add new line
                defaultsContent += `\n${interfaceLine}\n`;
            }
            
            // Ensure IPv6 is disabled for simplicity
            if (defaultsContent.includes('INTERFACESv6=')) {
                defaultsContent = defaultsContent.replace(/INTERFACESv6=.*/, 'INTERFACESv6=""');
            } else {
                defaultsContent += 'INTERFACESv6=""\n';
            }
            
            await fs.writeFile(defaultsPath, defaultsContent);
            logger.info(`DHCP server defaults configured for interface ${this.interface}`);
            
        } catch (error) {
            logger.error('Failed to configure DHCP defaults:', error);
            throw error;
        }
    }

    async startDHCPServer() {
        try {
            logger.info('Starting DHCP server...');
            
            // Stop any existing instance
            await this.executeCommand('systemctl stop isc-dhcp-server 2>/dev/null || true');
            
            // Start the service
            await this.executeCommand('systemctl start isc-dhcp-server');
            
            // Enable auto-start
            await this.executeCommand('systemctl enable isc-dhcp-server');
            
            // Verify it's running
            const status = await this.executeCommand('systemctl is-active isc-dhcp-server');
            if (status === 'active') {
                logger.info('DHCP server started successfully');
                this.isEnabled = true;
            } else {
                throw new Error('DHCP server failed to start');
            }
            
        } catch (error) {
            logger.error('Failed to start DHCP server:', error);
            
            // Try to get more detailed error information
            try {
                const journalOutput = await this.executeCommand('journalctl -u isc-dhcp-server --since "1 minute ago" --no-pager');
                logger.error('DHCP server journal output:', journalOutput);
            } catch (journalError) {
                // Ignore journal errors
            }
            
            throw error;
        }
    }

    async stopDHCPServer() {
        try {
            logger.info('Stopping DHCP server...');
            
            await this.executeCommand('systemctl stop isc-dhcp-server');
            await this.executeCommand('systemctl disable isc-dhcp-server');
            
            this.isEnabled = false;
            logger.info('DHCP server stopped');
            
        } catch (error) {
            logger.error('Failed to stop DHCP server:', error);
            throw error;
        }
    }

    async initialize() {
        try {
            logger.info('Initializing DHCP server for mesh network...');
            
            // Install DHCP server if needed
            await this.installDHCPServer();
            
            // Generate and write configuration
            await this.writeDHCPConfig();
            
            // Configure defaults
            await this.configureDHCPDefaults();
            
            // Start the server
            await this.startDHCPServer();
            
            logger.info('DHCP server initialized successfully');
            
        } catch (error) {
            logger.error('Failed to initialize DHCP server:', error);
            throw error;
        }
    }

    async getLeases() {
        try {
            const leasesContent = await fs.readFile(this.dhcpLeasesPath, 'utf8');
            const leases = [];
            
            // Parse DHCP leases file
            const leaseBlocks = leasesContent.split('lease ').slice(1);
            
            for (const block of leaseBlocks) {
                const lines = block.split('\n');
                const ipMatch = lines[0].match(/^([0-9.]+)/);
                
                if (ipMatch) {
                    const lease = {
                        ip: ipMatch[1],
                        mac: null,
                        hostname: null,
                        starts: null,
                        ends: null,
                        state: null
                    };
                    
                    for (const line of lines) {
                        const trimmed = line.trim();
                        if (trimmed.startsWith('hardware ethernet')) {
                            lease.mac = trimmed.split(' ')[2].replace(';', '');
                        } else if (trimmed.startsWith('client-hostname')) {
                            lease.hostname = trimmed.split('"')[1];
                        } else if (trimmed.startsWith('starts')) {
                            lease.starts = trimmed.split(' ').slice(2).join(' ').replace(';', '');
                        } else if (trimmed.startsWith('ends')) {
                            lease.ends = trimmed.split(' ').slice(2).join(' ').replace(';', '');
                        } else if (trimmed.startsWith('binding state')) {
                            lease.state = trimmed.split(' ')[2].replace(';', '');
                        }
                    }
                    
                    // Only include active leases
                    if (lease.state === 'active' && lease.mac) {
                        leases.push(lease);
                    }
                }
            }
            
            return leases;
            
        } catch (error) {
            logger.error('Failed to get DHCP leases:', error);
            return [];
        }
    }

    async getStatus() {
        try {
            const isActive = await this.executeCommand('systemctl is-active isc-dhcp-server 2>/dev/null || echo "inactive"');
            const isEnabled = await this.executeCommand('systemctl is-enabled isc-dhcp-server 2>/dev/null || echo "disabled"');
            
            const status = {
                active: isActive.trim() === 'active',
                enabled: isEnabled.trim() === 'enabled',
                interface: this.interface,
                subnet: this.meshSubnet,
                gateway: this.coordinatorIP,
                range: this.dhcpRange
            };
            
            if (status.active) {
                status.leases = await this.getLeases();
            }
            
            return status;
            
        } catch (error) {
            logger.error('Failed to get DHCP status:', error);
            return {
                active: false,
                enabled: false,
                error: error.message
            };
        }
    }

    async addStaticLease(mac, ip, hostname = null) {
        try {
            logger.info(`Adding static DHCP lease: ${mac} -> ${ip}`);
            
            const hostEntry = `
# Static lease for ${hostname || 'unknown host'}
host ${hostname || 'mesh-node'}-${mac.replace(/:/g, '')} {
    hardware ethernet ${mac};
    fixed-address ${ip};${hostname ? `\n    option host-name "${hostname}";` : ''}
}`;
            
            // Read current config
            let config = await fs.readFile(this.dhcpConfigPath, 'utf8');
            
            // Add host entry before the closing brace
            config = config.replace(/(\n# Host declarations[^\n]*\n)/, `$1${hostEntry}\n`);
            
            // Write updated config
            await fs.writeFile(this.dhcpConfigPath, config);
            
            // Restart DHCP server to apply changes
            await this.executeCommand('systemctl restart isc-dhcp-server');
            
            logger.info(`Static lease added successfully`);
            
        } catch (error) {
            logger.error('Failed to add static DHCP lease:', error);
            throw error;
        }
    }

    async cleanup() {
        try {
            logger.info('Cleaning up DHCP server...');
            
            await this.stopDHCPServer();
            
            // Restore backup config if it exists
            try {
                const backupFiles = await this.executeCommand(`ls ${this.dhcpConfigPath}.backup.* 2>/dev/null || echo ""`);
                if (backupFiles) {
                    const latestBackup = backupFiles.split('\n').pop();
                    if (latestBackup) {
                        await this.executeCommand(`cp ${latestBackup} ${this.dhcpConfigPath}`);
                        logger.info('Restored backup DHCP configuration');
                    }
                }
            } catch (error) {
                // No backup to restore
            }
            
            logger.info('DHCP server cleanup complete');
            
        } catch (error) {
            logger.error('Failed to cleanup DHCP server:', error);
        }
    }

    isRunning() {
        return this.isEnabled;
    }
}

module.exports = DHCPManager;
